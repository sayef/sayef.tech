<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<title>linked-list-basics</title><link href='https://fonts.googleapis.com/css?family=Open+Sans:400italic,700italic,700,400&subset=latin,latin-ext' rel='stylesheet' type='text/css' /><style type='text/css'>html {overflow-x: initial !important;}:root { --bg-color:#ffffff; --text-color:#333333; --select-text-bg-color:#B5D6FC; --select-text-font-color:auto; }
html { font-size: 14px; background-color: var(--bg-color); color: var(--text-color); font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; }
body { margin: 0px; padding: 0px; height: auto; bottom: 0px; top: 0px; left: 0px; right: 0px; font-size: 1rem; line-height: 1.42857; overflow-x: hidden; background: inherit; }
a.url { word-break: break-all; }
a:active, a:hover { outline: 0px; }
.in-text-selection, ::selection { text-shadow: none; background: var(--select-text-bg-color); color: var(--select-text-font-color); }
#write { margin: 0px auto; height: auto; width: inherit; word-break: normal; word-wrap: break-word; position: relative; padding-bottom: 70px; white-space: pre-wrap; overflow-x: visible; }
.first-line-indent #write p .md-line { text-indent: 0px; }
.first-line-indent #write li, .first-line-indent #write p, .first-line-indent #write p .md-line:first-child { text-indent: 2em; }
.for-image #write { padding-left: 8px; padding-right: 8px; }
body.typora-export { padding-left: 30px; padding-right: 30px; }
@media screen and (max-width: 500px) {
  body.typora-export { padding-left: 0px; padding-right: 0px; }
  .CodeMirror-sizer { margin-left: 0px !important; }
  .CodeMirror-gutters { display: none !important; }
}
#write > blockquote:first-child, #write > div:first-child, #write > figure:first-child, #write > ol:first-child, #write > p:first-child, #write > pre:first-child, #write > ul:first-child { margin-top: 30px; }
#write li > figure:first-child { margin-top: -20px; }
#write ol, #write ul { position: relative; }
img { max-width: 100%; vertical-align: middle; }
button, input, select, textarea { color: inherit; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-size: inherit; line-height: inherit; font-family: inherit; }
input[type="checkbox"], input[type="radio"] { line-height: normal; padding: 0px; }
*, ::after, ::before { box-sizing: border-box; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p, #write pre { width: inherit; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p { position: relative; }
h1, h2, h3, h4, h5, h6 { break-after: avoid-page; break-inside: avoid; orphans: 2; }
p { orphans: 4; }
h1 { font-size: 2rem; }
h2 { font-size: 1.8rem; }
h3 { font-size: 1.6rem; }
h4 { font-size: 1.4rem; }
h5 { font-size: 1.2rem; }
h6 { font-size: 1rem; }
h1, h2, h3, h4, h5, h6 { margin-top: 1rem; margin-bottom: 1rem; }
p { -webkit-margin-before: 1rem; -webkit-margin-after: 1rem; -webkit-margin-start: 0px; -webkit-margin-end: 0px; }
.mathjax-block { margin-top: 0px; margin-bottom: 0px; -webkit-margin-before: 0px; -webkit-margin-after: 0px; }
.hidden { display: none; }
.md-blockmeta { color: rgb(204, 204, 204); font-weight: 700; font-style: italic; }
a { cursor: pointer; }
sup.md-footnote { padding: 2px 4px; background-color: rgba(238, 238, 238, 0.7); color: rgb(85, 85, 85); border-radius: 4px; cursor: pointer; }
sup.md-footnote a, sup.md-footnote a:hover { color: inherit; text-transform: inherit; text-decoration: inherit; }
#write input[type="checkbox"] { cursor: pointer; width: inherit; height: inherit; }
figure { overflow-x: auto; margin: 1.2em 0px; max-width: calc(100% + 16px); padding: 0px; }
figure > table { margin: 0px !important; }
tr { break-inside: avoid; break-after: auto; }
thead { display: table-header-group; }
table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; break-inside: auto; text-align: left; }
table.md-table td { min-width: 80px; }
.CodeMirror-gutters { border-right: 0px; background-color: inherit; }
.CodeMirror { text-align: left; }
.CodeMirror-placeholder { opacity: 0.3; }
.CodeMirror pre { padding: 0px 4px; }
.CodeMirror-lines { padding: 0px; }
div.hr:focus { cursor: none; }
pre { white-space: pre-wrap; }
pre.contain-cm { white-space: normal; }
.CodeMirror-gutters { margin-right: 4px; }
.md-fences { font-size: 0.9rem; display: block; break-inside: avoid; text-align: left; overflow: visible; white-space: pre; background: inherit; position: relative !important; }
.md-diagram-panel { width: 100%; margin-top: 10px; text-align: center; padding-top: 0px; padding-bottom: 8px; overflow-x: auto; }
.md-fences.mock-cm { white-space: pre-wrap; }
.show-fences-line-number .md-fences { padding-left: 0px; }
.show-fences-line-number .md-fences.mock-cm { padding-left: 40px; }
.CodeMirror-line { break-inside: avoid; }
.footnotes { opacity: 0.8; font-size: 0.9rem; margin-top: 1em; margin-bottom: 1em; }
.footnotes + .footnotes { margin-top: 0px; }
.md-reset { margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: top; background: 0px 0px; text-decoration: none; text-shadow: none; float: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; -webkit-tap-highlight-color: transparent; line-height: normal; font-weight: 400; text-align: left; box-sizing: content-box; direction: ltr; }
li div { padding-top: 0px; }
blockquote { margin: 1rem 0px; }
li .mathjax-block, li p { margin: 0.5rem 0px; }
li { margin: 0px; position: relative; }
blockquote > :last-child { margin-bottom: 0px; }
blockquote > :first-child, li > :first-child { margin-top: 0px; }
.footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; white-space: normal; }
.footnote-line { white-space: pre-wrap; }
@media print {
  body, html { border: 1px solid transparent; height: 99%; break-after: avoid; break-before: avoid; }
  #write { margin-top: 0px; border-color: transparent !important; }
  .typora-export * { -webkit-print-color-adjust: exact; }
  html.blink-to-pdf { font-size: 13px; }
  .typora-export #write { padding-left: 1cm; padding-right: 1cm; padding-bottom: 0px; break-after: avoid; }
  .typora-export #write::after { height: 0px; }
  @page { margin: 20mm 0px; }
}
.footnote-line { margin-top: 0.714em; font-size: 0.7em; }
a img, img a { cursor: pointer; }
pre.md-meta-block { font-size: 0.8rem; min-height: 0.8rem; white-space: pre-wrap; background: rgb(204, 204, 204); display: block; overflow-x: hidden; }
p > img:only-child { display: block; margin: auto; }
.md-line > .md-image:only-child, p > .md-image:only-child { display: inline-block; width: 100%; text-align: center; }
#write .MathJax_Display { margin: 0.8em 0px 0px; }
.mathjax-block { white-space: pre; overflow: hidden; width: 100%; }
p + .mathjax-block { margin-top: -1.143rem; }
.mathjax-block:not(:empty)::after { display: none; }
[contenteditable="true"]:active, [contenteditable="true"]:focus { outline: 0px; box-shadow: none; }
.md-task-list-item { position: relative; list-style-type: none; }
.task-list-item.md-task-list-item { padding-left: 0px; }
.md-task-list-item > input { position: absolute; top: 0px; left: 0px; margin-left: -1.2em; margin-top: calc(1em - 10px); }
.math { font-size: 1rem; }
.md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-radius: 10px; }
.md-toc-content { position: relative; margin-left: 0px; }
.md-toc-content::after, .md-toc::after { display: none; }
.md-toc-item { display: block; color: rgb(65, 131, 196); }
.md-toc-item a { text-decoration: none; }
.md-toc-inner:hover { }
.md-toc-inner { display: inline-block; cursor: pointer; }
.md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: 700; }
.md-toc-h2 .md-toc-inner { margin-left: 2em; }
.md-toc-h3 .md-toc-inner { margin-left: 4em; }
.md-toc-h4 .md-toc-inner { margin-left: 6em; }
.md-toc-h5 .md-toc-inner { margin-left: 8em; }
.md-toc-h6 .md-toc-inner { margin-left: 10em; }
@media screen and (max-width: 48em) {
  .md-toc-h3 .md-toc-inner { margin-left: 3.5em; }
  .md-toc-h4 .md-toc-inner { margin-left: 5em; }
  .md-toc-h5 .md-toc-inner { margin-left: 6.5em; }
  .md-toc-h6 .md-toc-inner { margin-left: 8em; }
}
a.md-toc-inner { font-size: inherit; font-style: inherit; font-weight: inherit; line-height: inherit; }
.footnote-line a:not(.reversefootnote) { color: inherit; }
.md-attr { display: none; }
.md-fn-count::after { content: "."; }
code, pre, tt { font-family: var(--monospace); }
.md-comment { color: rgb(162, 127, 3); opacity: 0.8; font-family: var(--monospace); }
code { text-align: left; }
a.md-print-anchor { border-width: initial !important; border-style: none !important; border-color: initial !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: 0px !important; background: 0px 0px !important; text-decoration: initial !important; text-shadow: initial !important; }
.md-inline-math .MathJax_SVG .noError { display: none !important; }
.mathjax-block .MathJax_SVG_Display { text-align: center; margin: 1em 0px; position: relative; text-indent: 0px; max-width: none; max-height: none; min-height: 0px; min-width: 100%; width: auto; display: block !important; }
.MathJax_SVG_Display, .md-inline-math .MathJax_SVG_Display { width: auto; margin: inherit; display: inline-block !important; }
.MathJax_SVG .MJX-monospace { font-family: monospace; }
.MathJax_SVG .MJX-sans-serif { font-family: sans-serif; }
.MathJax_SVG { display: inline; font-style: normal; font-weight: 400; line-height: normal; zoom: 90%; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; }
.MathJax_SVG * { transition: none; }
.os-windows.monocolor-emoji .md-emoji { font-family: "Segoe UI Symbol", sans-serif; }
.md-diagram-panel > svg { max-width: 100%; }
[lang="flow"] svg, [lang="mermaid"] svg { max-width: 100%; }
[lang="mermaid"] .node text { font-size: 1rem; }
table tr th { border-bottom: 0px; }


:root { --side-bar-bg-color: #fafafa; --control-text-color: #777; }
@font-face { font-family: "Open Sans"; font-style: normal; font-weight: normal; src: local("Open Sans Regular"), url("./github/400.woff") format("woff"); }
@font-face { font-family: "Open Sans"; font-style: italic; font-weight: normal; src: local("Open Sans Italic"), url("./github/400i.woff") format("woff"); }
@font-face { font-family: "Open Sans"; font-style: normal; font-weight: bold; src: local("Open Sans Bold"), url("./github/700.woff") format("woff"); }
@font-face { font-family: "Open Sans"; font-style: italic; font-weight: bold; src: local("Open Sans Bold Italic"), url("./github/700i.woff") format("woff"); }
html { font-size: 16px; }
body { font-family: "Open Sans", "Clear Sans", "Helvetica Neue", Helvetica, Arial, sans-serif; color: rgb(51, 51, 51); line-height: 1.6; }
#write { max-width: 860px; margin: 0px auto; padding: 20px 30px 100px; }
#write > ul:first-child, #write > ol:first-child { margin-top: 30px; }
body > :first-child { margin-top: 0px !important; }
body > :last-child { margin-bottom: 0px !important; }
a { color: rgb(65, 131, 196); }
h1, h2, h3, h4, h5, h6 { position: relative; margin-top: 1rem; margin-bottom: 1rem; font-weight: bold; line-height: 1.4; cursor: text; }
h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor { text-decoration: none; }
h1 tt, h1 code { font-size: inherit; }
h2 tt, h2 code { font-size: inherit; }
h3 tt, h3 code { font-size: inherit; }
h4 tt, h4 code { font-size: inherit; }
h5 tt, h5 code { font-size: inherit; }
h6 tt, h6 code { font-size: inherit; }
h1 { padding-bottom: 0.3em; font-size: 2.25em; line-height: 1.2; border-bottom: 1px solid rgb(238, 238, 238); }
h2 { padding-bottom: 0.3em; font-size: 1.75em; line-height: 1.225; border-bottom: 1px solid rgb(238, 238, 238); }
h3 { font-size: 1.5em; line-height: 1.43; }
h4 { font-size: 1.25em; }
h5 { font-size: 1em; }
h6 { font-size: 1em; color: rgb(119, 119, 119); }
p, blockquote, ul, ol, dl, table { margin: 0.8em 0px; }
li > ol, li > ul { margin: 0px; }
hr { height: 2px; padding: 0px; margin: 16px 0px; background-color: rgb(231, 231, 231); border: 0px none; overflow: hidden; box-sizing: content-box; }
body > h2:first-child { margin-top: 0px; padding-top: 0px; }
body > h1:first-child { margin-top: 0px; padding-top: 0px; }
body > h1:first-child + h2 { margin-top: 0px; padding-top: 0px; }
body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child { margin-top: 0px; padding-top: 0px; }
a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 { margin-top: 0px; padding-top: 0px; }
h1 p, h2 p, h3 p, h4 p, h5 p, h6 p { margin-top: 0px; }
li p.first { display: inline-block; }
ul, ol { padding-left: 30px; }
ul:first-child, ol:first-child { margin-top: 0px; }
ul:last-child, ol:last-child { margin-bottom: 0px; }
blockquote { border-left: 4px solid rgb(223, 226, 229); padding: 0px 15px; color: rgb(119, 119, 119); }
blockquote blockquote { padding-right: 0px; }
table { padding: 0px; word-break: initial; }
table tr { border-top: 1px solid rgb(223, 226, 229); margin: 0px; padding: 0px; }
table tr:nth-child(2n), thead { background-color: rgb(248, 248, 248); }
table tr th { font-weight: bold; border-width: 1px 1px 0px; border-top-style: solid; border-right-style: solid; border-left-style: solid; border-top-color: rgb(223, 226, 229); border-right-color: rgb(223, 226, 229); border-left-color: rgb(223, 226, 229); border-image: initial; border-bottom-style: initial; border-bottom-color: initial; text-align: left; margin: 0px; padding: 6px 13px; }
table tr td { border: 1px solid rgb(223, 226, 229); text-align: left; margin: 0px; padding: 6px 13px; }
table tr th:first-child, table tr td:first-child { margin-top: 0px; }
table tr th:last-child, table tr td:last-child { margin-bottom: 0px; }
.CodeMirror-gutters { border-right: 1px solid rgb(221, 221, 221); }
.md-fences, code, tt { border: 1px solid rgb(223, 226, 229); background-color: rgb(248, 248, 248); border-radius: 3px; font-family: Consolas, "Liberation Mono", Courier, monospace; padding: 2px 4px 0px; font-size: 0.9em; }
.md-fences { margin-bottom: 15px; margin-top: 15px; padding: 8px 1em 6px; }
.md-task-list-item > input { margin-left: -1.3em; }
@media screen and (min-width: 914px) {
}
@media print {
  html { font-size: 13px; }
  table, pre { break-inside: avoid; }
  pre { word-wrap: break-word; }
}
.md-fences { background-color: rgb(248, 248, 248); }
#write pre.md-meta-block { padding: 1rem; font-size: 85%; line-height: 1.45; background-color: rgb(247, 247, 247); border: 0px; border-radius: 3px; color: rgb(119, 119, 119); margin-top: 0px !important; }
.mathjax-block > .code-tooltip { bottom: 0.375rem; }
#write > h3.md-focus::before { left: -1.5625rem; top: 0.375rem; }
#write > h4.md-focus::before { left: -1.5625rem; top: 0.285714rem; }
#write > h5.md-focus::before { left: -1.5625rem; top: 0.285714rem; }
#write > h6.md-focus::before { left: -1.5625rem; top: 0.285714rem; }
.md-image > .md-meta { border-radius: 3px; font-family: Consolas, "Liberation Mono", Courier, monospace; padding: 2px 0px 0px 4px; font-size: 0.9em; color: inherit; }
.md-tag { color: inherit; }
.md-toc { margin-top: 20px; padding-bottom: 20px; }
.sidebar-tabs { border-bottom: none; }
#typora-quick-open { border: 1px solid rgb(221, 221, 221); background-color: rgb(248, 248, 248); }
#typora-quick-open-item { background-color: rgb(250, 250, 250); border-color: rgb(254, 254, 254) rgb(229, 229, 229) rgb(229, 229, 229) rgb(238, 238, 238); border-style: solid; border-width: 1px; }
#md-notification::before { top: 10px; }
.on-focus-mode blockquote { border-left-color: rgba(85, 85, 85, 0.12); }
header, .context-menu, .megamenu-content, footer { font-family: "Segoe UI", Arial, sans-serif; }
.file-node-content:hover .file-node-icon, .file-node-content:hover .file-node-open-state { visibility: visible; }
.mac-seamless-mode #typora-sidebar { background-color: var(--side-bar-bg-color); }
.md-lang { color: rgb(180, 101, 77); }
.html-for-mac .context-menu { --item-hover-bg-color: #E6F0FE; }





 .typora-export p, .typora-export .footnote-line {white-space: normal;} 
</style>
</head>
<body class='typora-export' >
<div  id='write'  class = 'is-node'><h1><a name='header-n0' class='md-header-anchor '></a>Linked List Basics</h1><p>A linked list is a data structure for storing, searching, manipulating and doing many more with a list of data. ‘Array’ data structure has some limitations that can be overcome easily by the linked list having some dynamic features. Let’s see what a linked list can do –</p><ul><li>Successive elements are connected by pointers.</li><li>Last element points to NULL.</li><li>It can grow or shrink in size during execution of a program.</li><li>It can be made just as long as required.</li><li>It does not waste memory space.</li></ul><p><a href='http://sketchingdream.com/blog/wp-content/uploads/2015/08/1.png'><img src='http://sketchingdream.com/blog/wp-content/uploads/2015/08/1.png?w=300' alt='1' referrerPolicy='no-referrer' /></a></p><p>Fig: Liked List Structure</p><p>We must know the pointer to the first element of the list (called start, head, etc.).<br/>
**Insertion and Deletion in linked list:<br/>
**<br/>
For insertion:</p><ul><li>A record is created holding the new item.</li><li>The nextpointer of the new record is set to link it to the item which is to follow it in the list.</li><li>The nextpointer of the item which is to precede it must be modified to point to the new item.</li></ul><p><a href='http://sketchingdream.com/blog/wp-content/uploads/2015/08/2.png'><img src='http://sketchingdream.com/blog/wp-content/uploads/2015/08/2.png?w=300' alt='linked list insertion' referrerPolicy='no-referrer' /></a></p><p>Fig: Linked List Insertion</p><p>For deletion:</p><ul><li>The nextpointer of the item immediately preceding the one to be deleted is altered, and made to point to the item following the deleted item.</li></ul><p><a href='http://sketchingdream.com/blog/wp-content/uploads/2015/08/3.png'><img src='http://sketchingdream.com/blog/wp-content/uploads/2015/08/3.png?w=300' alt='Fig: Linekd List Deletion' referrerPolicy='no-referrer' /></a></p><p>Fig: Linekd List Deletion</p><p><strong>Array versus Linked Lists</strong></p><ul><li>Inserting/deleting an element at the end.</li><li>Randomly accessing any element.</li><li>Searching the list for a particular value.</li><li>Inserting an element.</li><li>Deleting an element.</li><li>Applications where sequential access is required.</li><li>In situations where the number of elements cannot be predicted beforehand.</li></ul><p><strong>Types of Lists</strong><br/>
Depending on the way in which the links are used to maintain adjacency, several different types of linked lists are possible.</p><p><strong>2. Circular linked list :</strong> The pointer from the last element in the list points back to the first element.</p><p><a href='http://sketchingdream.com/blog/wp-content/uploads/2015/08/4.png'><img src='http://sketchingdream.com/blog/wp-content/uploads/2015/08/4.png?w=300' alt='Fig: Circular Linked List' referrerPolicy='no-referrer' /></a></p><p>Fig: Circular Linked List</p><p><strong>3. Doubly linked list:</strong></p><ul><li>Pointers exist between adjacent nodes in both directions.</li><li>The list can be traversed either forward or backward.</li><li>Usually two pointers are maintained to keep track of the list, head and tail.</li></ul><p><a href='http://sketchingdream.com/blog/wp-content/uploads/2015/08/5.png'><img src='http://sketchingdream.com/blog/wp-content/uploads/2015/08/5.png?w=300' alt='Fig: Doubly Linked List' referrerPolicy='no-referrer' /></a></p><p>Fig: Doubly Linked List</p><p><strong>Basic Operations on a List</strong></p><ul><li>Creating a list</li><li>Traversing the list</li><li>Inserting an item in the list</li><li>Deleting an item from the list</li><li>Concatenating two lists into one</li></ul><p>First of all we need to declare a user defined structure that will carry the information and same type of pointer variable that will lead us to the next address of the element of the list.Let’s declare a node which will hold student info containing roll, name, age of any student and the pointer to the next student of the list.</p><p>_/* definition of a data node for holding student information */
struct node {
   int roll;
   char name[20];
   int  age;
   struct node *next;
};_</p><p>Initialization of the head node of the list from where we will always start our look up for insertion, deletion and searching any node on any key i.e. name, roll or age –</p><p>_/* head points to first node in list*/
struct node *head = (struct node *) NULL;_ </p><p>Allocating memory for the newly created node will be looking like the following-</p><p>_/* this initialises a node, allocates memory for the node, and returns   */
/* a pointer to the new node. Must pass it the node details, name and id */
struct node * initnode( int roll, char *name, int age )
{
   struct node *ptr;
   ptr = (struct node *) calloc( 1, sizeof(struct node ) );
   if( ptr == NULL )                       /* error allocating node?      */
       return (struct node <em>) NULL;        /</em> then return NULL, else      */
   else {                                  /* allocated node successfully */
       ptr-&gt;roll = roll;                   /* copy roll                   */
       strcpy( ptr-&gt;name, name );          /* fill in name details        */
       ptr-&gt;age = age;                     /* copy age                    */
       return ptr;                         /* return pointer to new node  */
   }
}_ </p><p>Or if we want to allocate memory so simply C++ provides the following API. Just we need to assign the name and id.</p><p>_struct node * initnode( int roll, char *name, int age )
{
  node *ptr; 
  ptr = new node();</p><p>  str-&gt;roll = roll;
  strcpy(ptr-&gt;name, name);
  ptr-&gt;age = age;</p><p>  return ptr;
}_</p><p>So our first node is created-</p><p><a href='http://sketchingdream.com/blog/wp-content/uploads/2015/08/6.png'><img src='http://sketchingdream.com/blog/wp-content/uploads/2015/08/6.png?w=300' alt='Fig: Head/First node' referrerPolicy='no-referrer' /></a></p><p>Fig: Head/First node</p><hr /><h6><a name='header-n175' class='md-header-anchor '></a><strong>CREATING LIST</strong></h6><hr /><p>If there are n number of nodes in the initial linked list:</p><ol start='' ><li><p>Allocate n records, one by one.</p></li><li><p>Read in the fields of the records.</p></li><li><p>Modify the links of the records so that the chain is formed.</p><p>_node create_list(int n, node *head)<span>	</span> <span>	</span> 
{<span>	</span> <span>	</span> 
 int i, n;<span>	</span> <span>	</span> 
 node *p; // pointer that will iterate through the list<span>	</span> <span>	</span> 
 p = head; //first pointer must be the head node<span>	</span> <span>	</span> 
 for(i=1; i&lt;=n; i++) { <span>	</span> <span>	</span> 
     scanf(&quot;%d %s %d&quot;, &amp;p-&gt;roll, p-&gt;name, &amp;p-&gt;age); //put the values in p<span>	</span> <span>	</span> 
     if(i==n) // for the last element<span>	</span> <span>	</span> 
     {<span>	</span> <span>	</span> 
        p-&gt;next = NULL; //there is no next element and this is the end of the list<span>	</span> <span>	</span> 
     }<span>	</span> <span>	</span> 
     else<span>	</span> <span>	</span> 
     {<span>	</span> <span>	</span> 
        node *nextNode = (node *) malloc(sizeof(node)); //allocating memory for the next node<span>	</span> <span>	</span> 
        p-&gt;next = nextNode; //pointing nextNode as the next node of p<span>	</span> <span>	</span> 
        p = p-&gt;next; //now p be the next node for the sake of iteration<span>	</span> <span>	</span> 
     }<span>	</span> <span>	</span> 
  }<span>	</span> <span>	</span> 
 }_</p></li></ol><hr /><p><strong>TRAVERSING LIST</strong></p><hr /><ol start='' ><li><p>Follow the pointers.</p></li><li><p>Display the contents of the nodes as they are traversed.</p></li><li><p>Stop when the nextpointer points to NULL.</p><p>_void display (node *head)<span>	</span> <span>	</span> 
{<span>	</span> <span>	</span> 
 int i = 1;<span>	</span> <span>	</span> 
 node *p;<span>	</span> <span>	</span> 
 p = head;<span>	</span> <span>	</span> 
 while (p != NULL)<span>	</span> <span>	</span> 
 {<span>	</span> <span>	</span> 
    printf(&quot;\nNode%d: %d %s %d&quot;, i, p-&gt;roll, p-&gt;name, p-&gt;age);<span>	</span> <span>	</span> 
    i++;<span>	</span> <span>	</span> 
    p = p-&gt;next;<span>	</span> <span>	</span> 
  }<span>	</span> <span>	</span> 
  printf(&quot;\n&quot;);<span>	</span> <span>	</span> 
 }_</p></li></ol><p>**INSERTING AN ITEM IN THE LIST<br/>
**</p><hr /><p>Suppose the problem is to insert a node before a specified node.</p><ul><li>Specified means some value is given for the node (called key).</li><li>In this example, we consider it to be roll.</li></ul><p>We have to maintain three different cases here.<br/>
<strong>Case 1: When a node is added at the beginning-</strong></p><ol start='' ><li>Only one next pointer needs to be modified.</li><li>A new node is made the head</li><li>New node points to the previously first element.</li></ol><p><a href='http://sketchingdream.com/blog/wp-content/uploads/2015/08/7.png'><img src='http://sketchingdream.com/blog/wp-content/uploads/2015/08/7.png?w=300' alt='Fig: Insert Before Head' referrerPolicy='no-referrer' /></a></p><p>Fig: Insert Before Head</p><p><strong>Case 2: When a node is added at the end-</strong></p><ol start='' ><li>Two next pointers need to be modified.</li><li>Last node now points to a new node.</li><li>New node points to NULL.</li></ol><p><a href='http://sketchingdream.com/blog/wp-content/uploads/2015/08/8.png'><img src='http://sketchingdream.com/blog/wp-content/uploads/2015/08/8.png?w=300' alt='Fig: Insert at the end' referrerPolicy='no-referrer' /></a></p><p>Fig: Insert at the end</p><ol start='' ><li>Two next pointers need to be modified.</li><li>Previous node now points to the new node.</li><li>New node points to the next node.</li></ol><p><a href='http://sketchingdream.com/blog/wp-content/uploads/2015/08/9.png'><img src='http://sketchingdream.com/blog/wp-content/uploads/2015/08/9.png?w=300' alt='Fig: Insert at the middle of two nodes' referrerPolicy='no-referrer' /></a></p><p>Fig: Insert at the middle of two nodes</p><p>Let’s see the code snippet for the insertion into the existing list:<br/>
Convention: Put it before a key (here we assume roll). If there is no such key put it to the last.</p><p> _//node new has new roll, name, age<span>	</span> <span>	</span> 
 //key is the roll of the node before which we will put the new node<span>	</span> <span>	</span> 
 void insert (node *head, node *new, int key)<span>	</span> <span>	</span> 
 {<span>	</span> <span>	</span> 
 <span>	</span>
   node *p, *q;<span>	</span> <span>	</span> 
   p = *head; // iterate starts from the head<span>	</span> <span>	</span> 
   if(p == null)<span>	</span> 
   {<span>	</span> <span>	</span> 
      new-&gt;next = p;<span>	</span> <span>	</span> 
      head = new;<span>	</span> <span>	</span> 
   }<span>	</span> <span>	</span> 
   else<span>	</span> <span>	</span> 
   {<span>	</span> <span>	</span> 
     while (p != NULL &amp;&amp; p-&gt;roll != key) //iterate as long as we reach the end or get the key<span>	</span> <span>	</span> 
     {<span>	</span> <span>	</span> 
        q = p; // q keeps track of the previous node<span>	</span> <span>	</span> 
        p = p-&gt;next;<span>	</span> <span>	</span> 
     }<span>	</span> <span>	</span> 
     else 
     {<span>	</span> <span>	</span> 
       q-&gt;next = new;<span>	</span> <span>	</span> 
       new-&gt;next = NULL;<span>	</span> <span>	</span> 
     }<span>	</span> <span>	</span> 
   }<span>	</span> <span>	</span> 
 }<span>	</span> <span>	</span> 
int main()<span>	</span> <span>	</span> 
{<span>	</span> <span>	</span> 
   ......<span>	</span> <span>	</span> 
   //assume the head and initial list is already created so far<span>	</span> <span>	</span> 
   ......<span>	</span> <span>	</span> 
   node *new = (node *) malloc(sizeof(node));<span>	</span> <span>	</span> 
   int key;<span>	</span> <span>	</span> 
   scanf(&quot;%d %s %d %d&quot;, &amp;new-&gt;roll, new-&gt;name, &amp;new-&gt;age, &amp;key); // take the info of new node and the key<span>	</span> <span>	</span> 
   insert(head, new, key);<span>	</span> <span>	</span> 
 }_ </p><hr /><p>**DELETING AN ITEM FROM THE LIST<br/>
**</p><hr /><p>Here also we are required to delete a specified node. Say, the node whose roll field is given as the key for the deletion. Here also three conditions arise:<br/>
<strong>Case 1: Delete the node at the beginning</strong></p><p><a href='http://sketchingdream.com/blog/wp-content/uploads/2015/08/10.png'><img src='http://sketchingdream.com/blog/wp-content/uploads/2015/08/10.png?w=300' alt='Fig: Delete the head ' referrerPolicy='no-referrer' /></a></p><p>Fig: Delete the first node / head</p><p>**Case 1: Delete the node at the end<br/>
**</p><p><a href='http://sketchingdream.com/blog/wp-content/uploads/2015/08/11.png'><img src='http://sketchingdream.com/blog/wp-content/uploads/2015/08/11.png?w=300' alt='Fig: Delete the last node' referrerPolicy='no-referrer' /></a></p><p>Fig: Delete the last node</p><p>**Case 1: Delete the node at the middle of two nodes<br/>
**<br/>
<a href='http://sketchingdream.com/blog/wp-content/uploads/2015/08/12.png'><img src='http://sketchingdream.com/blog/wp-content/uploads/2015/08/12.png?w=300' alt='12' referrerPolicy='no-referrer' /></a>Let’s see the code snippet which is as simple as the pictures say:</p><p> _void delete (node *head, int key)<span>	</span> <span>	</span> 
 {<span>	</span> <span>	</span> 
    node *p, *q;<span>	</span> <span>	</span> 
    p = *head; // iterate from the head<span>	</span> <span>	</span> 
    if (p-&gt;roll == key) /* if the first item to be deleted */<span>	</span> <span>	</span> 
    {<span>	</span> <span>	</span> 
      *head = p-&gt;next;<span>	</span> <span>	</span> 
      free (p); // free the memory allocated to the deleting node<span>	</span> <span>	</span> 
    }<span>	</span> <span>	</span> 
    else<span>	</span> <span>	</span> 
    {<span>	</span> <span>	</span> 
        while(p != NULL &amp;&amp; p-&gt;roll != key)<span>	</span> <span>	</span> 
        {<span>	</span> <span>	</span> 
           q = p; //storing the address of the previous node<span>	</span> <span>	</span> 
           p = p-&gt;next;<span>	</span> <span>	</span> 
        }<span>	</span> <span>	</span> 
        if(p == NULL) /* Element not found */<span>	</span> <span>	</span> 
           printf(&quot;\nNomatch :: deletion failed&quot;);<span>	</span> <span>	</span> 
        else if (p-&gt;roll == key) /* Delete a node at the middle of two nodes */<span>	</span> <span>	</span> 
        {<span>	</span> <span>	</span> 
           q-&gt;next = p-&gt;next; //Previous node now points the next node of the deleting item<span>	</span> <span>	</span> 
           free (p); // free the memory allocated to the deleting node<span>	</span> <span>	</span> 
        }<span>	</span> <span>	</span> 
    }<span>	</span> <span>	</span> 
 }_</p><p>So, these are the basics of the linked list. If you understand these operation, hope you will be able to implement the followings-</p><ol start='' ><li>Concatenate two given list into one big list.</li><li>Push, pop operation for Stack and Queue.</li><li>Implement Circular and Doubly linked list.</li></ol><p>Comment if anything is unclear to you or point me out if any mistake is sighted. Thanks.</p><p>Some implementations:</p><ol start='' ><li>ftp://gd.tuwien.ac.at/languages/c/programming-bbrown/c_094.htm</li><li><a href='http://www.thegeekstuff.com/2012/08/c-linked-list-example/' target='_blank' class='url'>http://www.thegeekstuff.com/2012/08/c-linked-list-example/</a></li></ol><hr /></div>
</body>
</html>